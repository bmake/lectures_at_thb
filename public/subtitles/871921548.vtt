WEBVTT - This file was automatically generated by VIMEO

0
00:00:02.890 --> 00:00:05.670
Now let's start with a short introduction to Sparkle.

1
00:00:05.850 --> 00:00:10.030
We will look at the definition and, uh, basic syntech elements.

2
00:00:10.770 --> 00:00:15.190
So Sparkle is a W three C standard for querying R D F data.

3
00:00:15.370 --> 00:00:19.950
And not only it is issued in the 1.1 version

4
00:00:20.250 --> 00:00:21.870
in 2013.

5
00:00:22.770 --> 00:00:26.430
And you can see here the direct link to the specification.

6
00:00:27.460 --> 00:00:31.070
Currently, there is a working group at the W three C,

7
00:00:31.320 --> 00:00:35.830
which prepare a new release, sparkle 1.2 with, uh,

8
00:00:35.860 --> 00:00:40.030
much more functionality, but we will work with 1.1. And, uh,

9
00:00:40.340 --> 00:00:45.270
this is the version which is implemented in the actual usable, um,

10
00:00:45.970 --> 00:00:50.750
um, R D F stores. This R Q L. So the,

11
00:00:50.890 --> 00:00:55.310
uh, lost three, um, characters in sparkl. They stands,

12
00:00:55.370 --> 00:00:58.030
stands for R D F query language.

13
00:00:58.370 --> 00:01:03.150
But since a variety of other data can be handled or can be transformed to

14
00:01:03.350 --> 00:01:07.790
R D F, it can also be applied to other data structures.

15
00:01:08.010 --> 00:01:12.510
So the base data structure, you can see here the R D F, uh, data structure.

16
00:01:12.530 --> 00:01:15.790
You have a subject and an object, and, uh,

17
00:01:15.790 --> 00:01:19.470
they are connected with a predicate, with a,

18
00:01:19.790 --> 00:01:24.510
a directed edge. And the object might be also a literal data.

19
00:01:25.100 --> 00:01:27.630
Then you have another kind of object.

20
00:01:27.770 --> 00:01:32.550
And the another kind of predicate and the predicates we divided in

21
00:01:33.260 --> 00:01:37.990
relations, if they are between, um, two nodes, um,

22
00:01:38.290 --> 00:01:42.590
two resource notes, uh, and we call them attributes,

23
00:01:43.210 --> 00:01:45.630
if they, um, um,

24
00:01:45.850 --> 00:01:50.550
are conne connect a subject with literal data. Uh, so they,

25
00:01:50.890 --> 00:01:55.350
uh, give us information about, um, characteristics of that, uh, subject,

26
00:01:55.530 --> 00:02:00.310
not relations, but, uh, characteristics. So, um, in the end,

27
00:02:00.610 --> 00:02:05.310
you can sparkle use also on relational data when you transform it to R D F,

28
00:02:05.610 --> 00:02:09.910
uh, also on XML or J data, or even on table data,

29
00:02:10.050 --> 00:02:11.110
as I already showed you.

30
00:02:12.290 --> 00:02:16.990
So sparkle is thus a powerful and extremely flexible language

31
00:02:17.370 --> 00:02:21.950
for business analytics. So then go, uh,

32
00:02:22.020 --> 00:02:24.990
back or forward. The P in Spark.

33
00:02:25.170 --> 00:02:27.270
QL stands for protocol.

34
00:02:27.750 --> 00:02:32.630
Protocol is a set of rules which enables the exchange of queries and

35
00:02:32.630 --> 00:02:36.070
results between the sparkle client and the server.

36
00:02:36.490 --> 00:02:40.830
So even our application could not work without using that protocol.

37
00:02:41.450 --> 00:02:46.430
And the first letter vs is only a recourse of acronym. So,

38
00:02:46.690 --> 00:02:51.510
uh, when you, um, decipher sparkle, then it, uh,

39
00:02:51.970 --> 00:02:56.230
sounds like sparkle port protocol and R D F query language.

40
00:02:56.530 --> 00:02:59.920
So Thess is, uh, simply, um, um,

41
00:03:00.450 --> 00:03:03.280
added to have a more, uh,

42
00:03:03.750 --> 00:03:07.600
speakable name and it's a little bit, uh,

43
00:03:08.120 --> 00:03:11.760
resembling the SQLs, the structured query language,

44
00:03:11.760 --> 00:03:14.320
which we have for relational databases.

45
00:03:16.340 --> 00:03:17.440
So how, uh,

46
00:03:17.540 --> 00:03:22.440
the basic sparkle syntax looks like you have,

47
00:03:22.540 --> 00:03:27.320
uh, first, uh, the Prophix definitions, which you already know,

48
00:03:27.500 --> 00:03:29.040
uh, from the total syntax,

49
00:03:29.420 --> 00:03:33.960
but they are a little bit different in totally remember you have first to use

50
00:03:34.180 --> 00:03:37.120
the ad symbol, then the keyword prophix,

51
00:03:37.460 --> 00:03:42.400
and then comes the prophix itself, which, uh, um, which ends with the column.

52
00:03:42.620 --> 00:03:44.080
And then after a space,

53
00:03:44.540 --> 00:03:48.840
you have the U R I for what this PROPHIX stands for.

54
00:03:49.740 --> 00:03:51.600
Uh, here the ad, um,

55
00:03:52.510 --> 00:03:57.280
character is omitted and you have only the keyword graphics

56
00:03:57.580 --> 00:04:02.360
and the, uh, other parts are similar in turtle. Um,

57
00:04:02.700 --> 00:04:05.520
it depends a little bit on the tools you use,

58
00:04:05.620 --> 00:04:10.400
but in turtle you have also after each perfect definition, definition,

59
00:04:10.560 --> 00:04:14.680
a.in here in, uh, spark ql, it's not necessary.

60
00:04:16.260 --> 00:04:20.840
And then, uh, you have, uh, two so-called clauses,

61
00:04:21.100 --> 00:04:25.200
the select C clause and the wear C clause and the select clause,

62
00:04:25.770 --> 00:04:29.640
enate enumerates, the, um, output variables,

63
00:04:29.690 --> 00:04:33.200
which you want to get as a, a result,

64
00:04:33.220 --> 00:04:37.640
as an output of the query. And the,

65
00:04:38.130 --> 00:04:43.040
let's call the main part or the main complicated part of the query,

66
00:04:43.540 --> 00:04:46.840
uh, is the wear clause, uh, which is,

67
00:04:47.210 --> 00:04:50.400
which uses the keyword wear,

68
00:04:50.940 --> 00:04:54.480
and where the graph pageant, which is, uh,

69
00:04:54.730 --> 00:04:59.280
given in total syntax, is enclosed in, uh,

70
00:04:59.690 --> 00:05:04.520
curly braces. So let's go on here.

71
00:05:04.580 --> 00:05:06.360
We define the, uh,

72
00:05:07.080 --> 00:05:11.800
reference standards and vocabularies and the colors. You can see here,

73
00:05:12.310 --> 00:05:15.760
they are the same as we used in the, um,

74
00:05:16.060 --> 00:05:20.240
in the schema or in the graph diagram at slide four. Yeah,

75
00:05:20.240 --> 00:05:23.680
you have this red, uh, for schema do org.

76
00:05:23.860 --> 00:05:27.480
You have the yellow or orange for provenance.

77
00:05:27.990 --> 00:05:32.240
This is the name of this standard vocabulary FO four

78
00:05:32.790 --> 00:05:37.520
four vocabulary. And, uh, our, um, individual, our,

79
00:05:38.100 --> 00:05:41.360
um, proprietary it cut, um,

80
00:05:41.920 --> 00:05:44.680
graphics for the specific, um,

81
00:05:45.620 --> 00:05:49.200
for the specific classes, uh,

82
00:05:49.210 --> 00:05:53.880
properties and individuals we use this. Um,

83
00:05:55.420 --> 00:05:59.120
you see here in the select line that, uh,

84
00:05:59.980 --> 00:06:01.960
the variables are listed,

85
00:06:02.270 --> 00:06:07.080
each variable starts with a question mark. And afterwards,

86
00:06:07.170 --> 00:06:11.880
afterwards, uh, different, uh, yeah, characters can be used, no,

87
00:06:12.340 --> 00:06:15.120
um, special characters. And, uh,

88
00:06:15.340 --> 00:06:20.080
the variable must not start with a number, but you can,

89
00:06:20.080 --> 00:06:24.880
afterwards, you can use also numbers if it's, uh, necessary. So,

90
00:06:25.300 --> 00:06:30.240
and there is also no restriction about the

91
00:06:30.240 --> 00:06:35.200
number of variables you can in the end, uh, query, uh,

92
00:06:35.340 --> 00:06:40.240
any number of variables and not all of them have to be returned.

93
00:06:40.460 --> 00:06:44.920
So there might be variables in the graph, no, in the, yeah, in the graph clause,

94
00:06:44.920 --> 00:06:49.040
in the wear clause, uh, which are not, um, output.

95
00:06:49.180 --> 00:06:53.840
And we will see such examples, um, in upcoming slides. Hmm.

96
00:06:54.540 --> 00:06:56.440
So here the list of the output variables,

97
00:06:56.460 --> 00:07:01.360
the specification of the query pattern. So let's start with some simple, uh,

98
00:07:01.600 --> 00:07:03.760
examples. If you, um,

99
00:07:04.870 --> 00:07:09.440
come along with a new knowledge graph and you want to analyze this

100
00:07:09.920 --> 00:07:10.080
graph,

101
00:07:10.080 --> 00:07:14.940
you want to imagine you don't have such a nice schema

102
00:07:15.000 --> 00:07:18.340
as I provided for you on slide number four, uh,

103
00:07:18.520 --> 00:07:22.220
and you want to analyze this non, um,

104
00:07:23.800 --> 00:07:28.740
or, or this unknown, uh, knowledge graph, then you can do such simple,

105
00:07:29.160 --> 00:07:33.700
um, analyzing queries. So we start with, um,

106
00:07:34.800 --> 00:07:38.900
the first that we want to get out all classes,

107
00:07:39.150 --> 00:07:42.380
which we have in this, um, in,

108
00:07:43.240 --> 00:07:47.900
in this knowledge graph. Yeah. So, uh, to, um,

109
00:07:50.930 --> 00:07:55.350
not to have, uh, too much or not to use too much place for the prefixes,

110
00:07:55.950 --> 00:08:00.830
I, um, I restricted it, it here to this one basic, uh,

111
00:08:00.970 --> 00:08:04.950
prefix. And I didn't, uh, repeat them afterwards.

112
00:08:05.130 --> 00:08:09.670
So in the end, you have here five different queries,

113
00:08:09.690 --> 00:08:12.870
and for all these queries, you have to, um,

114
00:08:13.340 --> 00:08:14.790
declare first the pre,

115
00:08:15.050 --> 00:08:19.510
but I didn't repeat it because it's the same in for all examples. Yeah,

116
00:08:19.970 --> 00:08:23.910
the, so this, oh, sorry, sorry, sorry. I didn't want to that.

117
00:08:24.890 --> 00:08:27.390
Uh, okay, let's use,

118
00:08:30.030 --> 00:08:33.230
let's use this. So,

119
00:08:34.910 --> 00:08:38.770
okay, we will start with, with this, um,

120
00:08:39.100 --> 00:08:44.090
first example, um, select the,

121
00:08:44.150 --> 00:08:49.130
the variable we call class. Yeah. The name of the variable, uh,

122
00:08:49.390 --> 00:08:52.410
is not, um, not essential.

123
00:08:52.430 --> 00:08:54.810
So you can name it as you want.

124
00:08:54.940 --> 00:08:58.920
You can also put a question mark and use an X,

125
00:08:59.220 --> 00:09:03.080
but it's better to use, uh, a word which, uh,

126
00:09:03.220 --> 00:09:07.560
can be understood. So, and what we are searching for,

127
00:09:07.780 --> 00:09:12.640
we are searching in our graph for all patterns,

128
00:09:12.690 --> 00:09:16.880
which are of the way, there is something our variable class,

129
00:09:17.380 --> 00:09:21.120
and this is an owl class. Yeah. Is of type owl class.

130
00:09:22.780 --> 00:09:26.080
So wait, that's not right.

131
00:09:29.660 --> 00:09:30.493
Uh,

132
00:09:31.740 --> 00:09:34.720
So now I want to, uh,

133
00:09:34.970 --> 00:09:38.800
leave the presentation mode to get this

134
00:09:40.690 --> 00:09:41.523
query

135
00:09:43.120 --> 00:09:43.953
In

136
00:09:45.560 --> 00:09:48.700
Memory. And then we go to our, um,

137
00:09:50.050 --> 00:09:54.980
sparkle endpoint on the Java server and

138
00:09:55.480 --> 00:09:59.360
we put the query here.

139
00:10:00.900 --> 00:10:05.880
So, uh, we use the right yeah, IT card.

140
00:10:05.880 --> 00:10:08.000
Yeah, here we see which, um,

141
00:10:10.750 --> 00:10:14.680
here you can also see which database we are querying.

142
00:10:15.220 --> 00:10:19.760
We can see that there are no syntactical errors in that query.

143
00:10:20.500 --> 00:10:24.360
And uh, we want to get a table output here,

144
00:10:24.660 --> 00:10:26.200
and then we can run the query.

145
00:10:29.540 --> 00:10:32.240
And here you have, uh, the output.

146
00:10:32.340 --> 00:10:36.800
So we get 13 entries, 30 outputs. Uh,

147
00:10:37.020 --> 00:10:39.640
so we see that we have 13 classes,

148
00:10:40.660 --> 00:10:43.800
and I suggest the number of all that boxes,

149
00:10:43.850 --> 00:10:46.600
which we had on slide number four.

150
00:10:47.260 --> 00:10:52.040
But what you get are the UR MRIs, um, of that classes.

151
00:10:52.500 --> 00:10:56.880
And that might be not very good readable. So we will, uh,

152
00:10:56.880 --> 00:11:00.280
come to other methods that we get, uh, as output,

153
00:11:00.540 --> 00:11:04.560
not the URIs of the classes itself, but of, uh, for instance,

154
00:11:04.560 --> 00:11:07.880
their labels or things like that. So, okay,

155
00:11:07.970 --> 00:11:12.680
let's try another one. Yeah, let's, let's take the next,

156
00:11:13.500 --> 00:11:17.560
we want to get all relations we have here.

157
00:11:20.420 --> 00:11:24.760
So let's put it here again.

158
00:11:27.940 --> 00:11:30.600
So we have 18 relations.

159
00:11:30.740 --> 00:11:35.440
The relations are all object properties in the graph, and, uh,

160
00:11:35.440 --> 00:11:39.360
they are here listed, um, as, um, yeah,

161
00:11:39.450 --> 00:11:44.040
again with their UIs. Now you can see here the related,

162
00:11:44.370 --> 00:11:49.040
which, uh, is from SCOs core. And you see here,

163
00:11:49.580 --> 00:11:53.720
um, the relation agent or the relation provider from schema.org.

164
00:11:54.660 --> 00:11:57.160
Um, what may be interesting,

165
00:11:57.760 --> 00:12:02.440
I told you that this application we built, um, roundabout eight years ago,

166
00:12:02.620 --> 00:12:06.800
and, uh, that time the, uh, H T T P S uh,

167
00:12:07.120 --> 00:12:11.640
protocol was not as prominent as today. Therefore, uh,

168
00:12:11.780 --> 00:12:15.480
at that time, schema.org even uses, uh,

169
00:12:15.540 --> 00:12:20.520
the HT t P protocol Nowadays. It may, uh, might be, uh,

170
00:12:20.520 --> 00:12:24.600
better to use HT T P ss. Okay?

171
00:12:25.980 --> 00:12:29.600
So maybe we, uh,

172
00:12:29.910 --> 00:12:31.920
take this last, for example,

173
00:12:38.140 --> 00:12:41.240
what we have here. Oh,

174
00:12:41.930 --> 00:12:43.760
there is an error.

175
00:12:46.650 --> 00:12:48.930
Interesting. Our class,

176
00:12:52.890 --> 00:12:56.950
ah, I D F S is not defined. Okay, this, this is true.

177
00:12:57.920 --> 00:12:58.790
Let's add it.

178
00:13:08.710 --> 00:13:10.650
So you see, you get here some help

179
00:13:12.750 --> 00:13:15.090
And now it's fine. Uh,

180
00:13:15.090 --> 00:13:19.850
because we use here the R D F S subclass off, and now we can run the query.

181
00:13:20.950 --> 00:13:24.930
Uh, oh, let's first think about what we are querying.

182
00:13:25.070 --> 00:13:29.650
So we are searching for all classes and subclasses. So classes are,

183
00:13:30.230 --> 00:13:34.850
um, all, um, items which are,

184
00:13:35.710 --> 00:13:38.010
um, represented as in our class.

185
00:13:39.750 --> 00:13:42.930
And we are searching also for the subclass of that classes.

186
00:13:45.470 --> 00:13:49.250
So what you get is a table you see here, um,

187
00:13:49.760 --> 00:13:54.090
only that classes, which are subclasses of others. Yeah.

188
00:13:54.270 --> 00:13:58.650
Or which have subclasses. Uh, it's better to say, uh, that way.

189
00:13:59.030 --> 00:14:03.890
So we have here the class agent. And the class agent, as we saw in the diagram,

190
00:14:05.800 --> 00:14:10.570
they have three, um, subclasses organization person enroll,

191
00:14:11.190 --> 00:14:15.210
and the class entity has two subclasses document.

192
00:14:15.350 --> 00:14:19.370
And asset qualitative value also have two subclasses,

193
00:14:19.770 --> 00:14:24.650
priority CRI criteria, criticality, and yeah,

194
00:14:24.650 --> 00:14:29.610
service property. I think this was not shown in my diagram.

195
00:14:30.430 --> 00:14:31.570
Uh, but here, this,

196
00:14:31.670 --> 00:14:35.970
you also could see service category has three sub

197
00:14:36.400 --> 00:14:41.090
classes, subject category, catalog, category, and lifecycle stage.

198
00:14:42.240 --> 00:14:43.070
Okay?

199
00:14:43.070 --> 00:14:47.770
So this was the first examples and the

200
00:14:47.990 --> 00:14:48.890
end of that part.
